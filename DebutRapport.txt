1)	Test de puissance
Pour le bucket sort avec un seuil de récursivité de 1, le test de puissance montre que le temps de l’algorithme selon le nombre d’éléments dans le tableau est environs égal à 10^-5.79467*x^1.06191 pour les exemplaires 0 à 9, 10^-5.69504*x^1.03607 pour 10 à 19 et 10^-5.66649*x^1.03137 pour 20 à 29. On peut donc s’attendre à ce que la complexité du bucket sort avec seuil de récursitvité de 1 s’approche du O(n).
Pour le bucket sort avec un seuil de récursivité de 10, le test de puissance montre que le temps de l’algorithme selon le nombre d’éléments dans le tableau est environs égal à 10^-6.10015*x^1.08307 pour les exemplaires 0 à 9, 10^-6.15782*x^1.07784 pour 10 à 19 et 10^-6.10817*x^1.06926 pour 20 à 29. On peut donc s’attendre à ce que la complexité du bucket sort avec seuil de récursitvité de 10 s’approche du O(n) aussi, mais que la constante multiplicative est plus petit qu’avec un seuil de 1. C’est donc plus rapide avec le seuil de 10.
Pour le merge sort avec un seuil de récursivité de 1, le test de puissance montre que le temps de l’algorithme selon le nombre d’éléments dans le tableau est environs égal à 10^-5.47692*x^1.07225 pour les exemplaires 0 à 9, 10^-5.50229*x^1.0702 pour 10 à 19 et 10^-5.4902*x^1.06863 pour 20 à 29. On peut donc s’attendre à ce que la complexité du merge sort avec seuil de récursitvité de 1 s’approche du O(n).
Pour le merge sort avec un seuil de récursivité de 10, le test de puissance montre que le temps de l’algorithme selon le nombre d’éléments dans le tableau est environs égal à 10^-6.10015*x^1.08307 pour les exemplaires 0 à 9, 10^-6.15782*x^1.07784 pour 10 à 19 et 10^-6.10817*x^1.06926 pour 20 à 29. On peut donc s’attendre à ce que la complexité du merge sort avec seuil de récursitvité de 10 s’approche du O(n) aussi, mais que la constante multiplicative est plus petit qu’avec un seuil de 1. C’est donc plus rapide avec le seuil de 10.

2)	Consommation théorique des algorithmes
Pour le bucket sort, la consommation théorique en meilleur cas et en cas moyen est de ϴ(n+k) où k est le nombre de bucket. Dans notre code, le nombre de bucket est égal au nombre d’éléments, donc ϴ(2n). Le pire cas est de O(n^2).
Pour le merge sort, la consommation théorique en meilleure cas, en pire cas et en cas moyen est de ϴ(n*log(n)).

3)	Test du rapport
Pour le bucket sort avec un seuil de récursivité de 1, le test du rapport montre que pour la série 0 à 9, la courbe du graphique semble converger vers 0.0000018 et pour les 2 autres, vers 0.00000165. Comme les 3 sont plus grand que 0, on en déduit que le cas moyen et le meilleur cas (complexité de ϴ(2n)) est sensé. Par contre, pour le pire cas (complexité de O(n^2)), les 3 droites sembles converger vers 0, ce qui démontre une sur-estimation de l’hypothèse.
Pour le bucket sort avec un seuil de récursivité de 10, le test du rapport montre que pour la série 0 à 9, la courbe du graphique semble converger vers 0.0000012 et pour les 2 autres, vers 0.000001. Comme les 3 sont plus grand que 0, on en déduit que le cas moyen et le meilleur cas (complexité de ϴ(2n)) est sensé. Par contre, pour le pire cas (complexité de O(n^2)), les 3 droites sembles converger vers 0, ce qui démontre une sur-estimation de l’hypothèse.
Pour le merge sort avec un seuil de récursivité de 1, le test du rapport montre que pour les 3 séries convergent vers 0.0000006. Comme les 3 sont plus grand que 0, on en déduit que la complexité de O(n*log(n)) est sensé. 
Pour le merge sort avec un seuil de récursivité de 10, le test du rapport montre que la série 0 à 9 converge vers 0.0000005 et les 2 autres vers 0.0000004. Comme les 3 sont plus grand que 0, on en déduit que la complexité de O(n*log(n)) est sensé. 

4)	Test des constantes
Pour les 2 bucket sort, le meilleur cas/cas moyen a été choisi (ϴ(2n)). Toutes les courbes semblent assez droites, donc les résultats obtenus devraient être assez significatifs. 
Pour le seuil de 1, les formules trouvées sont : 0.00000363164*x-0.0135279 pour la série 1 à 9, 0.00000324224*x-0.00467953 pour 10 à 19 et 0.00000325806*x-0.0053943 pour 20 à 29. Les coûts fixes négatifs sont assez étranges, mais selon Gnuplot, ces formules conviennent parfaitement à nos résultats avec des R^2 de 0.9998, 0.9999 et 1.0000.
Pour le seuil de 10, les formules trouvées sont : 0.00000363164*x-0.0135279 pour la série 1 à 9, 0.00000324224*x-0.00467953 pour 10 à 19 et 0.00000325806*x-0.0053943 pour 20 à 29. Encre une fois, les coûts fixes négatifs sont étranges, mais selon Gnuplot, ces formules conviennent parfaitement à nos résultats avec des R^2 de 0.9918, 0.9997 et 0.9998.
Pour les 2 merge sort, la complexité choisie est O(n*log(n)). Toutes les courbes semblent assez droites, donc les résultats obtenus devraient être assez significatifs. 
Pour le seuil de 1, les formules trouvées sont : 0.00000363164*x*log(x)-0.0135279 pour la série 1 à 9, 0.00000324224*x*log(x)-0.00467953 pour 10 à 19 et 0.00000325806*x*log(x)-0.0053943 pour 20 à 29. Encore une fois, les coûts fixes négatifs sont étranges, mais selon Gnuplot, ces formules conviennent parfaitement à nos résultats avec des R^2 de 0.9998, 0.9999 et 1.0000.
Pour le seuil de 10, les formules trouvées sont : 0.00000363164*x*log(x)-0.0135279 pour la série 1 à 9, 0.00000324224*x*log(x)-0.00467953 pour 10 à 19 et 0.00000325806*x*log(x)-0.0053943 pour 20 à 29. Encre une fois, les coûts fixes négatifs sont étranges, mais selon Gnuplot, ces formules conviennent parfaitement à nos résultats avec des R^2 de 0.9918, 0.9997 et 0.9998.

5)	Impact du choix d’un seuil de récursivité
En observant les différents temps d’exécution des algorithmes selon le seuil de récursivité choisi, il est facile de voir l’importance de ce choix. Trop petit ou trop grand et l’algorithme n’est plus optimisé. On remarque bien l’importance d’un seuil de récursivité en tant que tel lorsque l’on regarde la différence de temps entre nos algorithmes avec un seuil de 10 et de 1. Le tri est beaucoup plus rapide avec notre seuil de récursivité de 10 (trouvé expérimentalement).

6)	Conditions de sélection des algorithmes
En se basant sur nos droites ayant eu des R^2 les plus près de 1, le merge sort avec seuil de récursivité de 1 serait le bon choix pour des exemplaires de 100 nombres et moins. Ensuite, pour les exemplaires de 100 à 200 nombres, le merge sort avec seuil de récursivité de 10 devient plus avantageux. Pour les exemplaires de 200 à 300, choisir le bucket sort avec seuil de 1. Pour finir, pour les exemplaires contenant plus de 300 nombres, choisir le bucket sort avec seuil de 10.
